---
public: false
title: 'ISRって使ったことないけど何がすごいの？'
publishedDate: '2022.00.00'
modifiedDate: '2022.00.00'
description: 'template'
category: 'template'
---

## 目次

## はじめに

今回は Next.js の ISR についての解説をしていこうと思います。

すでに、いろんな記事で解説されていたりもするので、個人的に学びになったところをまとめていきます。

特に新しい話でもないですが、自分の理解が足りていなかったり SSR,SSG だけわかってればよくない？という甘えがあって、なかなか踏み込めていない場所だったので、ただの個人的なまとめになりそうですが、ご容赦くださいませ...

## レンダリングの変遷　　

### CSR

クライアント側でレンダリングを行うと、クライアント側で JavaScript を処理するので、処理を行う量が多くなるほどレンダリングに時間がかかってしまい表示速度が遅くなる。
seo 的にもよくないのかも？

### SSR

サーバー側でレンダリングを行いクライアント側に渡す。
CSR であったような表示が遅れたりするような問題は解決される。
ただ、ユーザーからのリクエストごとにサーバー側で処理が行われるからオーバーヘッドが発生する可能性はあるみたい。

### SSG

ビルド時にレンダリングが行われるため、CSR や SSR であったようなユーザからのリクエストごとにレンダリングを行う必要もないので速度が遅くなることもないみたい。
ユーザーに見せるのはすでに構築された HTML だから早いよね。
さらに有効に SSG を利用するためには、リクエストのたびにサーバー側から HTML を返すのではなく、CDN にキャッシュを持っておいてキャッシュを返して表示を行うという手法が有効的らしい。  
vercel は Vercel Edge Network という CDN が備えついているらしいよ。
vercel にデプロイすると自動的にコンテンツがキャッシュされてユーザーに高速に表示できるらしい。

---

コンテンツが大量にある場合

- 全てのページでデータの受け取りとレンダリングをしていたら時間がかかりすぎる
  複数人の人間がコンテンツを追加する場合など
- どのタイミングでビルドすればいいかわからないビルドとビルドの間にコンテンツの変化があった場合に対応できない
  という課題へのアプローチとして出てきたらしい。

  getStaticPaths の fallback の設定を true にするとデータ取得に関する箇所以外がレンダリングされた静的なページに fallback してくれるらしい。
  そういう意味での fallback なんだね。
  ビルド時にデータ取得とレンダリングが行われないページでユーザからのリクエストがあった場合にプリレンダリングはされている状態

  1. クライアント側に取得を要するデータが欠けている状態の HTML がサーブされる。(フォールバック)
  2. クライアントと同時にサーバー側でも必要なデータの取得とレンダリングが行われる
  3. それ以降のユーザーからのリクエストに対してすでにサーバー側で生成されたキャッシュを返す

  getStaticPaths の fallback の設定を 'blocking'にすると、ture の時にデータの取得がなされていない状態の不完全な HTML がクライアント側にサーブされてしまうという問題を解決できる。
  ture の時はデータの取得がなされていない状態の不完全な HTML を返していたのだが、'blocking'は文字通りこの挙動をブロックして、不完全な HTML を返さない。
  ユーザーから初めてリクエストがあったタイミングでクライアント側ではなくサーバー側でデータの取得とレンダリングが行われるため、完全な状態の HTML をクライアント側にサーブすることができるようになった。
  ユーザーに完全な HTML を表示することができて、初回のアクセス時にもレンダリングが完成された状態で表示することが可能になった。

  true はクライアント側でレンダリング
  "blocking"はサーバ側でレンダリング

### ISR

SSG ではビルド時や初回リクエスト時のキャッシュを使い回すことで効率的に表示することが可能になっていますが、コンテンツに変更があった場合に差分が反映されない。という問題を解決する。

SSG の挙動に加えて設定した時間ごとにバックグラウンドでデータの再取得と再レンダリングを行い HTML を再生成する。

使用方法は getStaticProps の return するオブジェクトの中の revalidate という プロパティ に対して秒数を指定するだけ。
この revalidate で設定した秒数ごとにバックグラウンドでデータの再取得と再レンダリングが行われる。

revalidate を 60 秒と設定した場合の流れ

1. 初回リクエスト時はキャッシュを返す
2. 60 秒経過した後のリクエストがあった場合キャッシュを表示しつつ、裏側でデータの再取得と再レンダリングを行う
3. 2.の後にリクエストがあった場合には、2.の時に裏側で再生成されたキャッシュを返す

ISR は便利だけど、変更した内容を即効で反映されていてほしかったり、初回リクエストユーザーにも最新の状態を確認してほしい場合には SSR だったり CSR の方がよかったりするみたい。

vercel にデプロイすると、ISR でキャッシュされたページの Response Headers には x-vercel-cache: HIT が含まれるので、確認できる。

ISR をした時には getStaticProps で revalidate を設定するのと合わせて、SSG の時にも説明した getStaticPaths の fallback で 'blocking',を設定しないと、revalidate 中のデータの再取得と再レンダリングがサーバー側で実行されないらしい。クライアント側で実行したいなら true でいいのかもしれないけど。

SWR を使うとクライアントでマウント後に最新のデータをフェッチすることができるので、一瞬古いキャッシュが表示されるけど、その後に最新のコンテンツが表示できる。
https://twitter.com/chibicode/status/1299500165418479616?s=20&t=3Cf1SXnfajafRXvfVi3-mA

## 質問

## 参考

- https://qiita.com/thesugar/items/47ec3d243d00ddd0b4ed
- https://zenn.dev/catnose99/articles/8bed46fb271e44

## さいごに

今までは感覚的に fallback とか revalidate とかの設定をしていた気がするけれども、それぞれの特徴に応じて使い分ける必要がある。  
個人的には Jamstack なブログとかメディアとかを作ることが多いので、大体 ISR で良さそうな気がするけれど、サービスを作る時には SSR？CSR で SWR？みたいなことを考えないといけませんね。
